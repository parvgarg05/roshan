===============================================
CUSTOMER PHONE OTP LOGIN SYSTEM - DOCUMENTATION
===============================================

This file contains all the code for the customer phone-based OTP authentication system
that was implemented but later removed. It can be re-enabled in the future if needed.

===============================================
1. DATABASE SCHEMA (prisma/schema.prisma)
===============================================

Add these models to your Prisma schema:

```prisma
model Customer {
  id        String   @id @default(cuid())
  name      String
  phone     String
  email     String
  createdAt DateTime @default(now())

  orders  Order[]
  ratings ProductRating[]

  @@unique([email, phone])
  @@index([email])
  @@index([phone])
}

model CustomerOtp {
  id         String   @id @default(cuid())
  phone      String
  codeHash   String
  expiresAt  DateTime
  consumedAt DateTime?
  createdAt  DateTime @default(now())

  @@index([phone, createdAt])
}
```

Also add to Order model:
```prisma
customerId String?
customer   Customer? @relation(fields: [customerId], references: [id], onDelete: SetNull)
```

After schema changes, run:
```
npx prisma db push
npx prisma generate
```

===============================================
2. AUTHENTICATION LIBRARY (lib/customer-auth.ts)
===============================================

```typescript
import { SignJWT, jwtVerify } from 'jose';

export const CUSTOMER_SESSION_COOKIE = 'customer_session';

const getJwtSecretKey = () => {
    const secret = process.env.JWT_SECRET || 'roshanlal_super_secret_dev_key_2025_override_this!';
    return new TextEncoder().encode(secret);
};

export interface CustomerSessionPayload {
    customerId: string;
    phone: string;
    [key: string]: any;
}

export async function signCustomerAuthToken(payload: CustomerSessionPayload) {
    const token = await new SignJWT(payload as any)
        .setProtectedHeader({ alg: 'HS256' })
        .setIssuedAt()
        .setExpirationTime('30d')
        .sign(getJwtSecretKey());

    return token;
}

export async function verifyCustomerAuthToken(token: string) {
    try {
        const verified = await jwtVerify(token, getJwtSecretKey());
        const payload = verified.payload as {
            customerId?: string;
            phone?: string;
            exp: number;
        };

        if (!payload.customerId || !payload.phone) {
            return null;
        }

        return {
            customerId: payload.customerId,
            phone: payload.phone,
            exp: payload.exp,
        };
    } catch {
        return null;
    }
}
```

===============================================
3. API ROUTE - REQUEST OTP
(app/api/auth/customer/request-otp/route.ts)
===============================================

```typescript
import { NextRequest, NextResponse } from 'next/server';
import crypto from 'crypto';
import { prisma } from '@/lib/prisma';

function normalizePhone(input: string): string | null {
    const digits = input.replace(/\D/g, '');
    if (!/^[6-9]\d{9}$/.test(digits)) return null;
    return digits;
}

export async function POST(req: NextRequest) {
    try {
        const body = await req.json();
        const normalizedPhone = normalizePhone(body?.phone || '');

        if (!normalizedPhone) {
            return NextResponse.json({ error: 'Enter a valid 10-digit Indian mobile number.' }, { status: 400 });
        }

        const recentOtpCount = await (prisma as any).customerOtp.count({
            where: {
                phone: normalizedPhone,
                createdAt: { gte: new Date(Date.now() - 15 * 60 * 1000) },
            },
        });

        if (recentOtpCount >= 5) {
            return NextResponse.json({ error: 'Too many OTP requests. Please try again later.' }, { status: 429 });
        }

        const otp = `${Math.floor(100000 + Math.random() * 900000)}`;
        const codeHash = crypto.createHash('sha256').update(otp).digest('hex');

        await (prisma as any).customerOtp.create({
            data: {
                phone: normalizedPhone,
                codeHash,
                expiresAt: new Date(Date.now() + 5 * 60 * 1000),
            },
        });

        console.log(`[customer-otp] ${normalizedPhone}: ${otp}`);
        
        // TODO: Send SMS via Twilio instead of console.log
        // await sendOtpSms(normalizedPhone, otp);

        return NextResponse.json({ success: true });
    } catch (error) {
        console.error('[customer-request-otp]', error);
        return NextResponse.json({ error: 'Failed to send OTP' }, { status: 500 });
    }
}
```

===============================================
4. API ROUTE - VERIFY OTP
(app/api/auth/customer/verify-otp/route.ts)
===============================================

```typescript
import { NextRequest, NextResponse } from 'next/server';
import crypto from 'crypto';
import { prisma } from '@/lib/prisma';
import { CUSTOMER_SESSION_COOKIE, signCustomerAuthToken } from '@/lib/customer-auth';

function normalizePhone(input: string): string | null {
    const digits = input.replace(/\D/g, '');
    if (!/^[6-9]\d{9}$/.test(digits)) return null;
    return digits;
}

export async function POST(req: NextRequest) {
    try {
        const body = await req.json();
        const normalizedPhone = normalizePhone(body?.phone || '');
        const otp = `${body?.otp || ''}`.trim();

        if (!normalizedPhone || !/^\d{6}$/.test(otp)) {
            return NextResponse.json({ error: 'Invalid phone or OTP.' }, { status: 400 });
        }

        const latestOtp = await (prisma as any).customerOtp.findFirst({
            where: {
                phone: normalizedPhone,
                consumedAt: null,
            },
            orderBy: { createdAt: 'desc' },
        });

        if (!latestOtp || latestOtp.expiresAt < new Date()) {
            return NextResponse.json({ error: 'OTP expired. Please request a new one.' }, { status: 400 });
        }

        const enteredHash = crypto.createHash('sha256').update(otp).digest('hex');
        if (enteredHash !== latestOtp.codeHash) {
            return NextResponse.json({ error: 'Incorrect OTP.' }, { status: 400 });
        }

        await (prisma as any).customerOtp.update({
            where: { id: latestOtp.id },
            data: { consumedAt: new Date() },
        });

        const existingCustomer = await prisma.customer.findFirst({
            where: { phone: normalizedPhone },
            orderBy: { createdAt: 'asc' },
        });

        const customer = existingCustomer || await prisma.customer.create({
            data: {
                phone: normalizedPhone,
                name: 'Customer',
                email: `${normalizedPhone}@phone.local`,
            },
        });

        const token = await signCustomerAuthToken({
            customerId: customer.id,
            phone: customer.phone,
        });

        const response = NextResponse.json({ success: true });
        response.cookies.set(CUSTOMER_SESSION_COOKIE, token, {
            httpOnly: true,
            secure: process.env.NODE_ENV === 'production',
            sameSite: 'lax',
            path: '/',
            maxAge: 60 * 60 * 24 * 30,
        });

        return response;
    } catch (error) {
        console.error('[customer-verify-otp]', error);
        return NextResponse.json({ error: 'Failed to verify OTP' }, { status: 500 });
    }
}
```

===============================================
5. API ROUTE - SESSION CHECK
(app/api/auth/customer/session/route.ts)
===============================================

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { CUSTOMER_SESSION_COOKIE, verifyCustomerAuthToken } from '@/lib/customer-auth';

export async function GET(req: NextRequest) {
    try {
        const token = req.cookies.get(CUSTOMER_SESSION_COOKIE)?.value;
        if (!token) {
            return NextResponse.json({ authenticated: false }, { status: 401 });
        }

        const session = await verifyCustomerAuthToken(token);
        if (!session) {
            return NextResponse.json({ authenticated: false }, { status: 401 });
        }

        const customer = await prisma.customer.findUnique({
            where: { id: session.customerId },
            select: {
                id: true,
                name: true,
                email: true,
                phone: true,
            },
        });

        if (!customer) {
            return NextResponse.json({ authenticated: false }, { status: 401 });
        }

        return NextResponse.json({
            authenticated: true,
            customer,
        });
    } catch (error) {
        console.error('[customer-session]', error);
        return NextResponse.json({ authenticated: false }, { status: 401 });
    }
}
```

===============================================
6. LOGIN UI PAGE
(app/(storefront)/auth/phone/page.tsx)
===============================================

```typescript
'use client';

import { useState, useEffect, Suspense } from 'react';
import { useRouter, useSearchParams } from 'next/navigation';
import { Phone, ShieldCheck } from 'lucide-react';
import Button from '@/components/ui/Button';
import Input from '@/components/ui/Input';

function normalizePhone(input: string) {
    return input.replace(/\D/g, '').slice(0, 10);
}

function CustomerPhoneLoginContent() {
    const router = useRouter();
    const searchParams = useSearchParams();
    const nextPath = searchParams.get('next') || '/checkout';

    const [phone, setPhone] = useState('');
    const [otp, setOtp] = useState('');
    const [otpSent, setOtpSent] = useState(false);
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState<string | null>(null);

    useEffect(() => {
        const checkSession = async () => {
            try {
                const res = await fetch('/api/auth/customer/session', { cache: 'no-store' });
                if (res.ok) {
                    router.replace(nextPath);
                }
            } catch {
                // no-op
            }
        };
        checkSession();
    }, [nextPath, router]);

    const requestOtp = async () => {
        setError(null);
        const normalizedPhone = normalizePhone(phone);

        if (!/^[6-9]\d{9}$/.test(normalizedPhone)) {
            setError('Enter a valid 10-digit Indian mobile number.');
            return;
        }

        setLoading(true);
        try {
            const res = await fetch('/api/auth/customer/request-otp', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ phone: normalizedPhone }),
            });

            const data = await res.json();
            if (!res.ok) {
                setError(data.error || 'Failed to send OTP.');
                return;
            }

            setPhone(normalizedPhone);
            setOtpSent(true);
        } catch {
            setError('Failed to send OTP. Please try again.');
        } finally {
            setLoading(false);
        }
    };

    const verifyOtp = async () => {
        setError(null);
        if (!/^\d{6}$/.test(otp)) {
            setError('Enter valid 6-digit OTP.');
            return;
        }

        setLoading(true);
        try {
            const res = await fetch('/api/auth/customer/verify-otp', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ phone, otp }),
            });
            const data = await res.json();

            if (!res.ok) {
                setError(data.error || 'OTP verification failed.');
                return;
            }

            router.replace(nextPath);
        } catch {
            setError('OTP verification failed. Please try again.');
        } finally {
            setLoading(false);
        }
    };

    return (
        <div className="min-h-screen bg-cream-100 flex items-center justify-center px-4 py-16">
            <div className="w-full max-w-md card-base p-6 space-y-5 hover:!-translate-y-0">
                <div className="text-center">
                    <div className="w-14 h-14 rounded-2xl bg-saffron-50 mx-auto mb-3 flex items-center justify-center">
                        <Phone size={24} className="text-saffron-600" />
                    </div>
                    <h1 className="font-display font-bold text-2xl text-maroon-900">Phone Login</h1>
                    <p className="text-maroon-500 text-sm mt-1">
                        Checkout continue karne ke liye mobile OTP verify karein.
                    </p>
                </div>

                <div className="space-y-4">
                    <Input
                        label="Mobile Number"
                        type="tel"
                        maxLength={10}
                        value={phone}
                        onChange={(e) => setPhone(normalizePhone(e.target.value))}
                        disabled={otpSent}
                        placeholder="9876543210"
                    />

                    {otpSent && (
                        <Input
                            label="OTP"
                            type="tel"
                            maxLength={6}
                            value={otp}
                            onChange={(e) => setOtp(e.target.value.replace(/\D/g, '').slice(0, 6))}
                            placeholder="6-digit OTP"
                        />
                    )}

                    {error && (
                        <p className="text-sm text-red-600 bg-red-50 border border-red-200 rounded-xl px-3 py-2">
                            {error}
                        </p>
                    )}

                    {!otpSent ? (
                        <Button variant="primary" size="lg" fullWidth onClick={requestOtp} loading={loading}>
                            Send OTP
                        </Button>
                    ) : (
                        <div className="space-y-2">
                            <Button variant="primary" size="lg" fullWidth onClick={verifyOtp} loading={loading}>
                                Verify & Continue
                            </Button>
                            <Button
                                variant="ghost"
                                size="md"
                                fullWidth
                                onClick={() => {
                                    setOtpSent(false);
                                    setOtp('');
                                }}
                            >
                                Change Number
                            </Button>
                        </div>
                    )}
                </div>

                <p className="text-xs text-maroon-400 flex items-center justify-center gap-1">
                    <ShieldCheck size={12} className="text-green-600" />
                    OTP based secure login for checkout
                </p>
            </div>
        </div>
    );
}

export default function CustomerPhoneLoginPage() {
    return (
        <Suspense fallback={<div>Loading...</div>}>
            <CustomerPhoneLoginContent />
        </Suspense>
    );
}
```

===============================================
7. MIDDLEWARE PROTECTION (middleware.ts)
===============================================

Add this to your middleware to protect routes:

```typescript
import { CUSTOMER_SESSION_COOKIE, verifyCustomerAuthToken } from '@/lib/customer-auth';

const CUSTOMER_PROTECTED_PATHS = ['/checkout', '/orders'];

// Inside middleware function:
const isCustomerProtectedRoute = CUSTOMER_PROTECTED_PATHS.some((path) => pathname.startsWith(path));
if (isCustomerProtectedRoute) {
    const sessionToken = req.cookies.get(CUSTOMER_SESSION_COOKIE)?.value;

    if (!sessionToken) {
        const loginUrl = new URL('/auth/phone', req.url);
        loginUrl.searchParams.set('next', `${pathname}${search}`);
        return NextResponse.redirect(loginUrl);
    }

    const verifiedSession = await verifyCustomerAuthToken(sessionToken);
    if (!verifiedSession) {
        const response = NextResponse.redirect(new URL('/auth/phone', req.url));
        response.cookies.delete(CUSTOMER_SESSION_COOKIE);
        return response;
    }

    return NextResponse.next();
}
```

===============================================
8. CHECKOUT FORM MODIFICATIONS
===============================================

In CheckoutForm.tsx, add session check:

```typescript
useEffect(() => {
    const checkSession = async () => {
        try {
            const res = await fetch('/api/auth/customer/session');
            if (res.ok) {
                const data = await res.json();
                if (data.authenticated && data.customer) {
                    setName(data.customer.name || '');
                    setEmail(data.customer.email || '');
                    setPhone(data.customer.phone || '');
                }
            }
        } catch (err) {
            console.error('Failed to check session:', err);
        }
    };
    checkSession();
}, []);
```

===============================================
9. ORDERS PAGE (app/(storefront)/orders/page.tsx)
===============================================

```typescript
import { cookies } from 'next/headers';
import { redirect } from 'next/navigation';
import { verifyCustomerAuthToken, CUSTOMER_SESSION_COOKIE } from '@/lib/customer-auth';
import { prisma } from '@/lib/prisma';

export default async function OrdersPage() {
    const cookieStore = await cookies();
    const token = cookieStore.get(CUSTOMER_SESSION_COOKIE)?.value;

    if (!token) {
        redirect('/auth/phone?next=/orders');
    }

    const session = await verifyCustomerAuthToken(token);
    if (!session) {
        redirect('/auth/phone?next=/orders');
    }

    const orders = await prisma.order.findMany({
        where: {
            customer: {
                phone: session.phone,
            },
        },
        include: {
            items: true,
        },
        orderBy: {
            createdAt: 'desc',
        },
    });

    // Render orders UI
    return (
        <div>
            {/* Display orders */}
        </div>
    );
}
```

===============================================
10. NAVIGATION LINKS
===============================================

Add to Navbar.tsx:
```typescript
<Link href="/orders">My Orders</Link>
```

Add to success page after payment:
```typescript
<Link href="/orders">View My Orders</Link>
```

===============================================
11. CREATE ORDER API MODIFICATION
===============================================

In app/api/checkout/create-order/route.ts:

```typescript
import { CUSTOMER_SESSION_COOKIE, verifyCustomerAuthToken } from '@/lib/customer-auth';

// Inside POST handler:
const sessionToken = req.cookies.get(CUSTOMER_SESSION_COOKIE)?.value;
if (!sessionToken) {
    return NextResponse.json({ error: 'Authentication required' }, { status: 401 });
}

const verifiedSession = await verifyCustomerAuthToken(sessionToken);
if (!verifiedSession) {
    return NextResponse.json({ error: 'Invalid session' }, { status: 401 });
}

// Use verifiedSession.phone instead of form phone
const customer = await prisma.customer.findFirst({
    where: { phone: verifiedSession.phone },
});

// Create order with customerId
await prisma.order.create({
    data: {
        // ... other fields
        customerId: customer.id,
    },
});
```

===============================================
12. ENVIRONMENT VARIABLES
===============================================

Add to .env:
```
JWT_SECRET=your_strong_random_secret_here_minimum_32_characters
```

===============================================
NOTES FOR FUTURE IMPLEMENTATION
===============================================

1. SMS Integration: Replace console.log in request-otp with actual Twilio SMS
2. Rate Limiting: Consider Redis for better rate limiting across instances
3. OTP Cleanup: Add a cron job to delete expired OTPs
4. Customer Profile: Add page for customers to update their info
5. Email Verification: Add optional email verification flow
6. Remember Device: Implement device tokens for trusted devices
7. Security: Consider adding CAPTCHA for OTP requests
8. Analytics: Track login attempts and success rates

===============================================
TO RE-ENABLE THIS SYSTEM
===============================================

1. Copy code from this file to respective locations
2. Run: npx prisma db push && npx prisma generate
3. Update middleware.ts with customer protection
4. Add JWT_SECRET to .env
5. Test OTP flow thoroughly
6. Configure Twilio for production SMS
7. Update checkout and orders pages

===============================================
END OF DOCUMENTATION
===============================================
